/*
 * Copyright (C) 2020 Southern Storm Software, Pty Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "internal-gift64.h"
#include "internal-util.h"

/* Round constants for GIFT-64 */
static uint8_t const GIFT64_RC[28] = {
    0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, 0x3D, 0x3B,
    0x37, 0x2F, 0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E,
    0x1D, 0x3A, 0x35, 0x2B, 0x16, 0x2C, 0x18, 0x30,
    0x21, 0x02, 0x05, 0x0B
};

int gift64b_init
    (gift64b_key_schedule_t *ks, const unsigned char *key, size_t key_len)
{
    if (!ks || !key || key_len != 16)
        return 0;
    ks->k[0] = be_load_word32(key);
    ks->k[1] = be_load_word32(key + 4);
    ks->k[2] = be_load_word32(key + 8);
    ks->k[3] = be_load_word32(key + 12);
    return 1;
}

/* http://programming.sirrida.de/perm_fn.html#bit_permute_step */
#define bit_permute_step(_y, mask, shift) \
    do { \
        uint16_t y = (_y); \
        uint16_t t = ((y >> (shift)) ^ y) & (mask); \
        (_y) = (y ^ t) ^ (t << (shift)); \
    } while (0)

/* http://programming.sirrida.de/perm_fn.html#bit_permute_step_simple */
#define bit_permute_step_simple(_y, mask, shift) \
    do { \
        (_y) = (((_y) & (mask)) << (shift)) | (((_y) >> (shift)) & (mask)); \
    } while (0)

/*
 * The permutation below was generated by the online permuation generator at
 * "http://programming.sirrida.de/calcperm.php".
 *
 * All of the permutuations are essentially the same, except that each is
 * rotated by 4 bits with respect to the next:
 *
 * P0: 0 12 8 4 1 13 9 5 2 14 10 6 3 15 11 7
 * P1: 4 0 12 8 5 1 13 9 6 2 14 10 7 3 15 11
 * P2: 8 4 0 12 9 5 1 13 10 6 2 14 11 7 3 15
 * P3: 12 8 4 0 13 9 5 1 14 10 6 2 15 11 7 3
 *
 * The most efficient permutation from the online generator was P1, so we
 * perform it as the core of the others, and then perform a final rotation.
 *
 * It is possible to do slightly better than "P1 then rotate" on desktop and
 * server architectures for the other permutations.  But the advantage isn't
 * as evident on embedded platforms so we keep things simple.
 */
#define PERM1_INNER(x) \
    do { \
        bit_permute_step(x, 0x0a0a, 3); \
        bit_permute_step(x, 0x00cc, 6); \
        bit_permute_step_simple(x, 0x0f0f, 4); \
    } while (0)
#define PERM0(x) \
    do { \
        uint32_t _x = (x); \
        PERM1_INNER(_x); \
        (x) = leftRotate12_16(_x); \
    } while (0)
#define PERM1(x) PERM1_INNER(x)
#define PERM2(x) \
    do { \
        uint32_t _x = (x); \
        PERM1_INNER(_x); \
        (x) = leftRotate4_16(_x); \
    } while (0)
#define PERM3(x) \
    do { \
        uint32_t _x = (x); \
        PERM1_INNER(_x); \
        (x) = leftRotate8_16(_x); \
    } while (0)

#define INV_PERM1_INNER(x) \
    do { \
        bit_permute_step(x, 0x0505, 5); \
        bit_permute_step(x, 0x00cc, 6); \
        bit_permute_step_simple(x, 0x0f0f, 4); \
    } while (0)
#define INV_PERM0(x) \
    do { \
        uint32_t _x = rightRotate12_16(x); \
        INV_PERM1_INNER(_x); \
        (x) = _x; \
    } while (0)
#define INV_PERM1(x) INV_PERM1_INNER(x)
#define INV_PERM2(x) \
    do { \
        uint32_t _x = rightRotate4_16(x); \
        INV_PERM1_INNER(_x); \
        (x) = _x; \
    } while (0)
#define INV_PERM3(x) \
    do { \
        uint32_t _x = rightRotate8_16(x); \
        INV_PERM1_INNER(_x); \
        (x) = _x; \
    } while (0)

void gift64b_encrypt
    (const gift64b_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    uint16_t s0, s1, s2, s3;
    uint32_t w0, w1, w2, w3;
    uint32_t temp;
    uint8_t round;

    /* Copy the plaintext into the state buffer and convert from big endian */
    s0 = be_load_word16(input);
    s1 = be_load_word16(input + 2);
    s2 = be_load_word16(input + 4);
    s3 = be_load_word16(input + 6);

    /* The key schedule is initialized with the key itself */
    w0 = ks->k[0];
    w1 = ks->k[1];
    w2 = ks->k[2];
    w3 = ks->k[3];

    /* Perform all 28 rounds */
    for (round = 0; round < 28; ++round) {
        /* SubCells - apply the S-box */
        s1 ^= s0 & s2;
        s0 ^= s1 & s3;
        s2 ^= s0 | s1;
        s3 ^= s2;
        s1 ^= s3;
        s3 ^= 0xFFFFU;
        s2 ^= s0 & s1;
        temp = s0;
        s0 = s3;
        s3 = temp;

        /* PermBits - apply the 64-bit permutation */
        PERM0(s0);
        PERM1(s1);
        PERM2(s2);
        PERM3(s3);

        /* AddRoundKey - XOR in the key schedule and the round constant */
        s0 ^= (uint16_t)w3;
        s1 ^= (uint16_t)(w3 >> 16);
        s3 ^= 0x8000U ^ GIFT64_RC[round];

        /* Rotate the key schedule */
        temp = w3;
        w3 = w2;
        w2 = w1;
        w1 = w0;
        w0 = ((temp & 0xFFFC0000U) >> 2) | ((temp & 0x00030000U) << 14) |
             ((temp & 0x00000FFFU) << 4) | ((temp & 0x0000F000U) >> 12);
    }

    /* Pack the state into the ciphertext buffer in big endian */
    be_store_word16(output,     s0);
    be_store_word16(output + 2, s1);
    be_store_word16(output + 4, s2);
    be_store_word16(output + 6, s3);
}

void gift64b_decrypt
    (const gift64b_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    uint16_t s0, s1, s2, s3;
    uint32_t w0, w1, w2, w3;
    uint32_t temp;
    uint8_t round;

    /* Copy the ciphertext into the state buffer and convert from big endian */
    s0 = be_load_word16(input);
    s1 = be_load_word16(input + 2);
    s2 = be_load_word16(input + 4);
    s3 = be_load_word16(input + 6);

    /* Generate the decryption key at the end of the last round.
     *
     * To do that, we run the block operation forward to determine the
     * final state of the key schedule after the last round:
     *
     * w0 = ks->k[0];
     * w1 = ks->k[1];
     * w2 = ks->k[2];
     * w3 = ks->k[3];
     * for (round = 0; round < 28; ++round) {
     *     temp = w3;
     *     w3 = w2;
     *     w2 = w1;
     *     w1 = w0;
     *     w0 = ((temp & 0xFFFC0000U) >> 2) | ((temp & 0x00030000U) << 14) |
     *          ((temp & 0x00000FFFU) << 4) | ((temp & 0x0000F000U) >> 12);
     * }
     *
     * We can short-cut all of the above by noticing that we don't need
     * to do the word rotations.  Every 4 rounds, the rotation alignment
     * returns to the original position and each word has been rotated
     * by applying the "2 right and 4 left" bit-rotation step to it.
     * We then repeat that 7 times for the full 28 rounds.  The overall
     * effect is to apply a "14 right and 28 left" bit-rotation to every word
     * in the key schedule.  That is equivalent to "14 right and 12 left"
     * on the 16-bit sub-words.
     */
    w0 = ks->k[0];
    w1 = ks->k[1];
    w2 = ks->k[2];
    w3 = ks->k[3];
    w0 = ((w0 & 0xC0000000U) >> 14) | ((w0 & 0x3FFF0000U) << 2) |
         ((w0 & 0x0000000FU) << 12) | ((w0 & 0x0000FFF0U) >> 4);
    w1 = ((w1 & 0xC0000000U) >> 14) | ((w1 & 0x3FFF0000U) << 2) |
         ((w1 & 0x0000000FU) << 12) | ((w1 & 0x0000FFF0U) >> 4);
    w2 = ((w2 & 0xC0000000U) >> 14) | ((w2 & 0x3FFF0000U) << 2) |
         ((w2 & 0x0000000FU) << 12) | ((w2 & 0x0000FFF0U) >> 4);
    w3 = ((w3 & 0xC0000000U) >> 14) | ((w3 & 0x3FFF0000U) << 2) |
         ((w3 & 0x0000000FU) << 12) | ((w3 & 0x0000FFF0U) >> 4);

    /* Perform all 28 rounds */
    for (round = 28; round > 0; --round) {
        /* Rotate the key schedule backwards */
        temp = w0;
        w0 = w1;
        w1 = w2;
        w2 = w3;
        w3 = ((temp & 0x3FFF0000U) << 2) | ((temp & 0xC0000000U) >> 14) |
             ((temp & 0x0000FFF0U) >> 4) | ((temp & 0x0000000FU) << 12);

        /* AddRoundKey - XOR in the key schedule and the round constant */
        s0 ^= (uint16_t)w3;
        s1 ^= (uint16_t)(w3 >> 16);
        s3 ^= 0x8000U ^ GIFT64_RC[round - 1];

        /* InvPermBits - apply the inverse of the 128-bit permutation */
        INV_PERM0(s0);
        INV_PERM1(s1);
        INV_PERM2(s2);
        INV_PERM3(s3);

        /* InvSubCells - apply the inverse of the S-box */
        temp = s0;
        s0 = s3;
        s3 = temp;
        s2 ^= s0 & s1;
        s3 ^= 0xFFFFU;
        s1 ^= s3;
        s3 ^= s2;
        s2 ^= s0 | s1;
        s0 ^= s1 & s3;
        s1 ^= s0 & s2;
    }

    /* Pack the state into the plaintext buffer in big endian */
    be_store_word16(output,     s0);
    be_store_word16(output + 2, s1);
    be_store_word16(output + 4, s2);
    be_store_word16(output + 6, s3);
}

int gift64n_init
    (gift64n_key_schedule_t *ks, const unsigned char *key, size_t key_len)
{
    /* Use the little-endian byte order from the LOTUS-AEAD submission */
    if (!ks || !key || key_len != 16)
        return 0;
    ks->k[0] = le_load_word32(key + 12);
    ks->k[1] = le_load_word32(key + 8);
    ks->k[2] = le_load_word32(key + 4);
    ks->k[3] = le_load_word32(key);
    return 1;
}

/* http://programming.sirrida.de/perm_fn.html#bit_permute_step */
#define bit_permute_step_32(_y, mask, shift) \
    do { \
        uint32_t y = (_y); \
        uint32_t t = ((y >> (shift)) ^ y) & (mask); \
        (_y) = (y ^ t) ^ (t << (shift)); \
    } while (0)

/**
 * \brief Converts the GIFT-64 nibble-based representation into word-based.
 *
 * \param output Output buffer to write the word-based version to.
 * \param input Input buffer to read the nibble-based version from.
 *
 * The \a input and \a output buffers can be the same buffer.
 */
static void gift64n_to_words
    (unsigned char *output, const unsigned char *input)
{
    uint32_t s0, s1;

    /* Load the input buffer into 32-bit words.  We use the nibble order from
     * the LOTUS-AEAD submission to NIST which is byte-reversed with respect
     * to the nibble order of the original GIFT-64 paper.  Nibble zero is in
     * the first byte instead of the last, which means little-endian order. */
    s0 = le_load_word32(input + 4);
    s1 = le_load_word32(input);

    /* Rearrange the bits so that bits 0..3 of each nibble are
     * scattered to bytes 0..3 of each word.  The permutation is:
     *
     * 0 8 16 24 1 9 17 25 2 10 18 26 3 11 19 27 4 12 20 28 5 13 21 29 6 14 22 30 7 15 23 31
     *
     * Generated with "http://programming.sirrida.de/calcperm.php".
     */
    #define PERM_WORDS(_x) \
        do { \
            uint32_t x = (_x); \
            bit_permute_step_32(x, 0x0a0a0a0a, 3); \
            bit_permute_step_32(x, 0x00cc00cc, 6); \
            bit_permute_step_32(x, 0x0000f0f0, 12); \
            bit_permute_step_32(x, 0x0000ff00, 8); \
            (_x) = x; \
        } while (0)
    PERM_WORDS(s0);
    PERM_WORDS(s1);

    /* Rearrange the bytes and write them to the output buffer */
    output[0] = (uint8_t)s0;
    output[1] = (uint8_t)s1;
    output[2] = (uint8_t)(s0 >> 8);
    output[3] = (uint8_t)(s1 >> 8);
    output[4] = (uint8_t)(s0 >> 16);
    output[5] = (uint8_t)(s1 >> 16);
    output[6] = (uint8_t)(s0 >> 24);
    output[7] = (uint8_t)(s1 >> 24);
}

/**
 * \brief Converts the GIFT-64 word-based representation into nibble-based.
 *
 * \param output Output buffer to write the nibble-based version to.
 * \param input Input buffer to read the word-based version from.
 */
static void gift64n_to_nibbles
    (unsigned char *output, const unsigned char *input)
{
    uint32_t s0, s1;

    /* Load the input bytes and rearrange them so that s0 contains the
     * most significant nibbles and s1 contains the least significant */
    s0 = (((uint32_t)(input[6])) << 24) |
         (((uint32_t)(input[4])) << 16) |
         (((uint32_t)(input[2])) <<  8) |
          ((uint32_t)(input[0]));
    s1 = (((uint32_t)(input[7])) << 24) |
         (((uint32_t)(input[5])) << 16) |
         (((uint32_t)(input[3])) <<  8) |
          ((uint32_t)(input[1]));

    /* Apply the inverse of PERM_WORDS() from the function above */
    #define INV_PERM_WORDS(_x) \
        do { \
            uint32_t x = (_x); \
            bit_permute_step_32(x, 0x00aa00aa, 7); \
            bit_permute_step_32(x, 0x0000cccc, 14); \
            bit_permute_step_32(x, 0x00f000f0, 4); \
            bit_permute_step_32(x, 0x0000ff00, 8); \
            (_x) = x; \
        } while (0)
    INV_PERM_WORDS(s0);
    INV_PERM_WORDS(s1);

    /* Store the result into the output buffer as 32-bit words */
    le_store_word32(output + 4, s0);
    le_store_word32(output,     s1);
}

void gift64n_encrypt
    (const gift64n_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    gift64n_to_words(output, input);
    gift64b_encrypt(ks, output, output);
    gift64n_to_nibbles(output, output);
}

void gift64n_decrypt
    (const gift64n_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    gift64n_to_words(output, input);
    gift64b_decrypt(ks, output, output);
    gift64n_to_nibbles(output, output);
}

/* 4-bit tweak values expanded to 16-bit */
static uint16_t const GIFT64_tweaks[16] = {
    0x0000, 0xe1e1, 0xd2d2, 0x3333, 0xb4b4, 0x5555, 0x6666, 0x8787,
    0x7878, 0x9999, 0xaaaa, 0x4b4b, 0xcccc, 0x2d2d, 0x1e1e, 0xffff
};

void gift64t_encrypt
    (const gift64n_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input, unsigned char tweak)
{
    uint16_t s0, s1, s2, s3;
    uint32_t w0, w1, w2, w3;
    uint32_t temp;
    uint8_t round;

    /* Copy the plaintext into the state buffer and convert from nibbles */
    gift64n_to_words(output, input);
    s0 = be_load_word16(output);
    s1 = be_load_word16(output + 2);
    s2 = be_load_word16(output + 4);
    s3 = be_load_word16(output + 6);

    /* The key schedule is initialized with the key itself */
    w0 = ks->k[0];
    w1 = ks->k[1];
    w2 = ks->k[2];
    w3 = ks->k[3];

    /* Perform all 28 rounds */
    for (round = 0; round < 28; ++round) {
        /* SubCells - apply the S-box */
        s1 ^= s0 & s2;
        s0 ^= s1 & s3;
        s2 ^= s0 | s1;
        s3 ^= s2;
        s1 ^= s3;
        s3 ^= 0xFFFFU;
        s2 ^= s0 & s1;
        temp = s0;
        s0 = s3;
        s3 = temp;

        /* PermBits - apply the 64-bit permutation */
        PERM0(s0);
        PERM1(s1);
        PERM2(s2);
        PERM3(s3);

        /* AddRoundKey - XOR in the key schedule and the round constant */
        s0 ^= (uint16_t)w3;
        s1 ^= (uint16_t)(w3 >> 16);
        s3 ^= 0x8000U ^ GIFT64_RC[round];

        /* AddTweak - XOR in the tweak every 4 rounds except the last */
        if (((round + 1) % 4) == 0 && round < 27)
            s2 ^= GIFT64_tweaks[tweak];

        /* Rotate the key schedule */
        temp = w3;
        w3 = w2;
        w2 = w1;
        w1 = w0;
        w0 = ((temp & 0xFFFC0000U) >> 2) | ((temp & 0x00030000U) << 14) |
             ((temp & 0x00000FFFU) << 4) | ((temp & 0x0000F000U) >> 12);
    }

    /* Pack the state into the ciphertext buffer in nibble form */
    be_store_word16(output,     s0);
    be_store_word16(output + 2, s1);
    be_store_word16(output + 4, s2);
    be_store_word16(output + 6, s3);
    gift64n_to_nibbles(output, output);
}

void gift64t_decrypt
    (const gift64n_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input, unsigned char tweak)
{
    uint16_t s0, s1, s2, s3;
    uint32_t w0, w1, w2, w3;
    uint32_t temp;
    uint8_t round;

    /* Copy the ciphertext into the state buffer and convert from nibbles */
    gift64n_to_words(output, input);
    s0 = be_load_word16(output);
    s1 = be_load_word16(output + 2);
    s2 = be_load_word16(output + 4);
    s3 = be_load_word16(output + 6);

    /* Generate the decryption key at the end of the last round.
     *
     * To do that, we run the block operation forward to determine the
     * final state of the key schedule after the last round:
     *
     * w0 = ks->k[0];
     * w1 = ks->k[1];
     * w2 = ks->k[2];
     * w3 = ks->k[3];
     * for (round = 0; round < 28; ++round) {
     *     temp = w3;
     *     w3 = w2;
     *     w2 = w1;
     *     w1 = w0;
     *     w0 = ((temp & 0xFFFC0000U) >> 2) | ((temp & 0x00030000U) << 14) |
     *          ((temp & 0x00000FFFU) << 4) | ((temp & 0x0000F000U) >> 12);
     * }
     *
     * We can short-cut all of the above by noticing that we don't need
     * to do the word rotations.  Every 4 rounds, the rotation alignment
     * returns to the original position and each word has been rotated
     * by applying the "2 right and 4 left" bit-rotation step to it.
     * We then repeat that 7 times for the full 28 rounds.  The overall
     * effect is to apply a "14 right and 28 left" bit-rotation to every word
     * in the key schedule.  That is equivalent to "14 right and 12 left"
     * on the 16-bit sub-words.
     */
    w0 = ks->k[0];
    w1 = ks->k[1];
    w2 = ks->k[2];
    w3 = ks->k[3];
    w0 = ((w0 & 0xC0000000U) >> 14) | ((w0 & 0x3FFF0000U) << 2) |
         ((w0 & 0x0000000FU) << 12) | ((w0 & 0x0000FFF0U) >> 4);
    w1 = ((w1 & 0xC0000000U) >> 14) | ((w1 & 0x3FFF0000U) << 2) |
         ((w1 & 0x0000000FU) << 12) | ((w1 & 0x0000FFF0U) >> 4);
    w2 = ((w2 & 0xC0000000U) >> 14) | ((w2 & 0x3FFF0000U) << 2) |
         ((w2 & 0x0000000FU) << 12) | ((w2 & 0x0000FFF0U) >> 4);
    w3 = ((w3 & 0xC0000000U) >> 14) | ((w3 & 0x3FFF0000U) << 2) |
         ((w3 & 0x0000000FU) << 12) | ((w3 & 0x0000FFF0U) >> 4);

    /* Perform all 28 rounds */
    for (round = 28; round > 0; --round) {
        /* Rotate the key schedule backwards */
        temp = w0;
        w0 = w1;
        w1 = w2;
        w2 = w3;
        w3 = ((temp & 0x3FFF0000U) << 2) | ((temp & 0xC0000000U) >> 14) |
             ((temp & 0x0000FFF0U) >> 4) | ((temp & 0x0000000FU) << 12);

        /* AddTweak - XOR in the tweak every 4 rounds except the last */
        if ((round % 4) == 0 && round != 28)
            s2 ^= GIFT64_tweaks[tweak];

        /* AddRoundKey - XOR in the key schedule and the round constant */
        s0 ^= (uint16_t)w3;
        s1 ^= (uint16_t)(w3 >> 16);
        s3 ^= 0x8000U ^ GIFT64_RC[round - 1];

        /* InvPermBits - apply the inverse of the 128-bit permutation */
        INV_PERM0(s0);
        INV_PERM1(s1);
        INV_PERM2(s2);
        INV_PERM3(s3);

        /* InvSubCells - apply the inverse of the S-box */
        temp = s0;
        s0 = s3;
        s3 = temp;
        s2 ^= s0 & s1;
        s3 ^= 0xFFFFU;
        s1 ^= s3;
        s3 ^= s2;
        s2 ^= s0 | s1;
        s0 ^= s1 & s3;
        s1 ^= s0 & s2;
    }

    /* Pack the state into the plaintext buffer in nibble form */
    be_store_word16(output,     s0);
    be_store_word16(output + 2, s1);
    be_store_word16(output + 4, s2);
    be_store_word16(output + 6, s3);
    gift64n_to_nibbles(output, output);
}
