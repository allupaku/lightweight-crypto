/*
 * Copyright (C) 2019 Southern Storm Software, Pty Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "gift128.h"
#include "util-rotate.h"
#include "util-load-store.h"

/* Round constants for GIFT-128 */
static uint8_t const GIFT128_RC[40] = {
    0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3E, 0x3D, 0x3B,
    0x37, 0x2F, 0x1E, 0x3C, 0x39, 0x33, 0x27, 0x0E,
    0x1D, 0x3A, 0x35, 0x2B, 0x16, 0x2C, 0x18, 0x30,
    0x21, 0x02, 0x05, 0x0B, 0x17, 0x2E, 0x1C, 0x38,
    0x31, 0x23, 0x06, 0x0D, 0x1B, 0x36, 0x2D, 0x1A
};

int gift128b_init
    (gift128b_key_schedule_t *ks, const unsigned char *key, size_t key_len)
{
    if (!ks || !key || key_len != 16)
        return 0;
    ks->k[0] = be_load_word32(key);
    ks->k[1] = be_load_word32(key + 4);
    ks->k[2] = be_load_word32(key + 8);
    ks->k[3] = be_load_word32(key + 12);
    return 1;
}

/* http://programming.sirrida.de/perm_fn.html#bit_permute_step */
#define bit_permute_step(_y, mask, shift) \
    (__extension__ ({ uint32_t y = (_y); \
       uint32_t t = ((y >> (shift)) ^ y) & (mask); \
       (y ^ t) ^ (t << (shift)); \
    }))

/*
 * The permutation below was generated by the online permuation generator at
 * "http://programming.sirrida.de/calcperm.php".
 *
 * All of the permutuations are essentially the same, except that each is
 * rotated by 8 bits with respect to the next:
 *
 * P0: 0 24 16 8 1 25 17 9 2 26 18 10 3 27 19 11 4 28 20 12 5 29 21 13 6 30 22 14 7 31 23 15
 * P1: 8 0 24 16 9 1 25 17 10 2 26 18 11 3 27 19 12 4 28 20 13 5 29 21 14 6 30 22 15 7 31 23
 * P2: 16 8 0 24 17 9 1 25 18 10 2 26 19 11 3 27 20 12 4 28 21 13 5 29 22 14 6 30 23 15 7 31
 * P3: 24 16 8 0 25 17 9 1 26 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7
 *
 * The most efficient permutation from the online generator was P3, so we
 * perform it as the core of the others, and then perform a final rotation.
 *
 * It is possible to do slightly better than "P3 then rotate" on desktop and
 * server architectures for the other permutations.  But the advantage isn't
 * as evident on embedded platforms so we keep things simple.
 */
#define PERM3(_x) \
    (__extension__ ({ uint32_t x = (_x); \
       x = bit_permute_step(x, 0x0a0a0a0a, 3); \
       x = bit_permute_step(x, 0x00cc00cc, 6); \
       x = bit_permute_step(x, 0x0000f0f0, 12); \
       x = bit_permute_step(x, 0x000000ff, 24); \
       x; }))
#define PERM0(z)     leftRotate8(PERM3(z))
#define PERM1(z)     leftRotate16(PERM3(z))
#define PERM2(z)     leftRotate24(PERM3(z))

#define INV_PERM3(_x) \
    (__extension__ ({ uint32_t x = (_x); \
       x = bit_permute_step(x, 0x00550055, 9); \
       x = bit_permute_step(x, 0x00003333, 18); \
       x = bit_permute_step(x, 0x000f000f, 12); \
       x = bit_permute_step(x, 0x000000ff, 24); \
       x; }))
#define INV_PERM0(z) INV_PERM3(rightRotate8(z))
#define INV_PERM1(z) INV_PERM3(rightRotate16(z))
#define INV_PERM2(z) INV_PERM3(rightRotate24(z))

void gift128b_encrypt
    (const gift128b_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    uint32_t s0, s1, s2, s3;
    uint32_t w0, w1, w2, w3;
    uint32_t temp;
    uint8_t round;

    /* Copy the plaintext into the state buffer and convert from big endian */
    s0 = be_load_word32(input);
    s1 = be_load_word32(input + 4);
    s2 = be_load_word32(input + 8);
    s3 = be_load_word32(input + 12);

    /* The key schedule is initialized with the key itself */
    w0 = ks->k[0];
    w1 = ks->k[1];
    w2 = ks->k[2];
    w3 = ks->k[3];

    /* Perform all 40 rounds */
    for (round = 0; round < 40; ++round) {
        /* SubCells - apply the S-box */
        s1 ^= s0 & s2;
        s0 ^= s1 & s3;
        s2 ^= s0 | s1;
        s3 ^= s2;
        s1 ^= s3;
        s3 ^= 0xFFFFFFFFU;
        s2 ^= s0 & s1;
        temp = s0;
        s0 = s3;
        s3 = temp;

        /* PermBits - apply the 128-bit permutation */
        s0 = PERM0(s0);
        s1 = PERM1(s1);
        s2 = PERM2(s2);
        s3 = PERM3(s3);

        /* AddRoundKey - XOR in the key schedule and the round constant */
        s2 ^= w1;
        s1 ^= w3;
        s3 ^= 0x80000000U ^ GIFT128_RC[round];

        /* Rotate the key schedule */
        temp = w3;
        w3 = w2;
        w2 = w1;
        w1 = w0;
        w0 = ((temp & 0xFFFC0000U) >> 2) | ((temp & 0x00030000U) << 14) |
             ((temp & 0x00000FFFU) << 4) | ((temp & 0x0000F000U) >> 12);
    }

    /* Pack the state into the ciphertext buffer in big endian */
    be_store_word32(output,      s0);
    be_store_word32(output + 4,  s1);
    be_store_word32(output + 8,  s2);
    be_store_word32(output + 12, s3);
}

void gift128b_decrypt
    (const gift128b_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    uint32_t s0, s1, s2, s3;
    uint32_t w0, w1, w2, w3;
    uint32_t temp;
    uint8_t round;

    /* Copy the ciphertext into the state buffer and convert from big endian */
    s0 = be_load_word32(input);
    s1 = be_load_word32(input + 4);
    s2 = be_load_word32(input + 8);
    s3 = be_load_word32(input + 12);

    /* Generate the decryption key at the end of the last round.
     *
     * To do that, we run the block operation forward to determine the
     * final state of the key schedule after the last round:
     *
     * w0 = ks->k[0];
     * w1 = ks->k[1];
     * w2 = ks->k[2];
     * w3 = ks->k[3];
     * for (round = 0; round < 40; ++round) {
     *     temp = w3;
     *     w3 = w2;
     *     w2 = w1;
     *     w1 = w0;
     *     w0 = ((temp & 0xFFFC0000U) >> 2) | ((temp & 0x00030000U) << 14) |
     *          ((temp & 0x00000FFFU) << 4) | ((temp & 0x0000F000U) >> 12);
     * }
     *
     * We can short-cut all of the above by noticing that we don't need
     * to do the word rotations.  Every 4 rounds, the rotation alignment
     * returns to the original position and each word has been rotated
     * by applying the "2 right and 4 left" bit-rotation step to it.
     * We then repeat that 10 times for the full 40 rounds.  The overall
     * effect is to apply a "20 right and 40 left" bit-rotation to every
     * word in the key schedule.  That is equivalent to "4 right and 8 left"
     * on the 16-bit sub-words.
     */
    w0 = ks->k[0];
    w1 = ks->k[1];
    w2 = ks->k[2];
    w3 = ks->k[3];
    w0 = ((w0 & 0xFFF00000U) >> 4) | ((w0 & 0x000F0000U) << 12) |
         ((w0 & 0x000000FFU) << 8) | ((w0 & 0x0000FF00U) >> 8);
    w1 = ((w1 & 0xFFF00000U) >> 4) | ((w1 & 0x000F0000U) << 12) |
         ((w1 & 0x000000FFU) << 8) | ((w1 & 0x0000FF00U) >> 8);
    w2 = ((w2 & 0xFFF00000U) >> 4) | ((w2 & 0x000F0000U) << 12) |
         ((w2 & 0x000000FFU) << 8) | ((w2 & 0x0000FF00U) >> 8);
    w3 = ((w3 & 0xFFF00000U) >> 4) | ((w3 & 0x000F0000U) << 12) |
         ((w3 & 0x000000FFU) << 8) | ((w3 & 0x0000FF00U) >> 8);

    /* Perform all 40 rounds */
    for (round = 40; round > 0; --round) {
        /* Rotate the key schedule backwards */
        temp = w0;
        w0 = w1;
        w1 = w2;
        w2 = w3;
        w3 = ((temp & 0x3FFF0000U) << 2) | ((temp & 0xC0000000U) >> 14) |
             ((temp & 0x0000FFF0U) >> 4) | ((temp & 0x0000000FU) << 12);

        /* AddRoundKey - XOR in the key schedule and the round constant */
        s2 ^= w1;
        s1 ^= w3;
        s3 ^= 0x80000000U ^ GIFT128_RC[round - 1];

        /* InvPermBits - apply the inverse of the 128-bit permutation */
        s0 = INV_PERM0(s0);
        s1 = INV_PERM1(s1);
        s2 = INV_PERM2(s2);
        s3 = INV_PERM3(s3);

        /* InvSubCells - apply the inverse of the S-box */
        temp = s0;
        s0 = s3;
        s3 = temp;
        s2 ^= s0 & s1;
        s3 ^= 0xFFFFFFFFU;
        s1 ^= s3;
        s3 ^= s2;
        s2 ^= s0 | s1;
        s0 ^= s1 & s3;
        s1 ^= s0 & s2;
    }

    /* Pack the state into the plaintext buffer in big endian */
    be_store_word32(output,      s0);
    be_store_word32(output + 4,  s1);
    be_store_word32(output + 8,  s2);
    be_store_word32(output + 12, s3);
}

int gift128n_init
    (gift128n_key_schedule_t *ks, const unsigned char *key, size_t key_len)
{
    /* Key schedule is identical for bit-sliced and nibble-based versions */
    return gift128b_init(ks, key, key_len);
}

/**
 * \brief Converts the GIFT-128 nibble-based representation into word-based.
 *
 * \param output Output buffer to write the word-based version to.
 * \param input Input buffer to read the nibble-based version from.
 *
 * The \a input and \a output buffers can be the same buffer.
 */
static void gift128n_to_words
    (unsigned char *output, const unsigned char *input)
{
    uint32_t s0, s1, s2, s3;

    /* Load the input buffer into 32-bit words */
    s0 = be_load_word32(input);
    s1 = be_load_word32(input + 4);
    s2 = be_load_word32(input + 8);
    s3 = be_load_word32(input + 12);

    /* Rearrange the bits so that bits 0..3 of each nibble are
     * scattered to bytes 0..3 of each word.  The permutation is:
     *
     * 0 8 16 24 1 9 17 25 2 10 18 26 3 11 19 27 4 12 20 28 5 13 21 29 6 14 22 30 7 15 23 31
     *
     * Generated with "http://programming.sirrida.de/calcperm.php".
     */
    #define PERM_WORDS(_x) \
        (__extension__ ({ uint32_t x = (_x); \
            x = bit_permute_step(x, 0x0a0a0a0a, 3); \
            x = bit_permute_step(x, 0x00cc00cc, 6); \
            x = bit_permute_step(x, 0x0000f0f0, 12); \
            x = bit_permute_step(x, 0x0000ff00, 8); \
            x; }))
    s0 = PERM_WORDS(s0);
    s1 = PERM_WORDS(s1);
    s2 = PERM_WORDS(s2);
    s3 = PERM_WORDS(s3);

    /* Rearrange the bytes and write them to the output buffer */
    output[0]  = (uint8_t)s0;
    output[1]  = (uint8_t)s1;
    output[2]  = (uint8_t)s2;
    output[3]  = (uint8_t)s3;
    output[4]  = (uint8_t)(s0 >> 8);
    output[5]  = (uint8_t)(s1 >> 8);
    output[6]  = (uint8_t)(s2 >> 8);
    output[7]  = (uint8_t)(s3 >> 8);
    output[8]  = (uint8_t)(s0 >> 16);
    output[9]  = (uint8_t)(s1 >> 16);
    output[10] = (uint8_t)(s2 >> 16);
    output[11] = (uint8_t)(s3 >> 16);
    output[12] = (uint8_t)(s0 >> 24);
    output[13] = (uint8_t)(s1 >> 24);
    output[14] = (uint8_t)(s2 >> 24);
    output[15] = (uint8_t)(s3 >> 24);
}

/**
 * \brief Converts the GIFT-128 word-based representation into nibble-based.
 *
 * \param output Output buffer to write the nibble-based version to.
 * \param input Input buffer to read the word-based version from.
 */
static void gift128n_to_nibbles
    (unsigned char *output, const unsigned char *input)
{
    uint32_t s0, s1, s2, s3;

    /* Load the input bytes and rearrange them so that s0 contains the
     * most significant nibbles and s3 contains the least significant */
    s0 = (((uint32_t)(input[12])) << 24) |
         (((uint32_t)(input[8]))  << 16) |
         (((uint32_t)(input[4]))  <<  8) |
          ((uint32_t)(input[0]));
    s1 = (((uint32_t)(input[13])) << 24) |
         (((uint32_t)(input[9]))  << 16) |
         (((uint32_t)(input[5]))  <<  8) |
          ((uint32_t)(input[1]));
    s2 = (((uint32_t)(input[14])) << 24) |
         (((uint32_t)(input[10])) << 16) |
         (((uint32_t)(input[6]))  <<  8) |
          ((uint32_t)(input[2]));
    s3 = (((uint32_t)(input[15])) << 24) |
         (((uint32_t)(input[11])) << 16) |
         (((uint32_t)(input[7]))  <<  8) |
          ((uint32_t)(input[3]));

    /* Apply the inverse of PERM_WORDS() from the function above */
    #define INV_PERM_WORDS(_x) \
        (__extension__ ({ uint32_t x = (_x); \
            x = bit_permute_step(x, 0x00aa00aa, 7); \
            x = bit_permute_step(x, 0x0000cccc, 14); \
            x = bit_permute_step(x, 0x00f000f0, 4); \
            x = bit_permute_step(x, 0x0000ff00, 8); \
            x; }))
    s0 = INV_PERM_WORDS(s0);
    s1 = INV_PERM_WORDS(s1);
    s2 = INV_PERM_WORDS(s2);
    s3 = INV_PERM_WORDS(s3);

    /* Store the result into the output buffer as 32-bit words */
    be_store_word32(output,      s0);
    be_store_word32(output + 4,  s1);
    be_store_word32(output + 8,  s2);
    be_store_word32(output + 12, s3);
}

void gift128n_encrypt
    (const gift128n_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    gift128n_to_words(output, input);
    gift128b_encrypt(ks, output, output);
    gift128n_to_nibbles(output, output);
}

void gift128n_decrypt
    (const gift128n_key_schedule_t *ks, unsigned char *output,
     const unsigned char *input)
{
    gift128n_to_words(output, input);
    gift128b_decrypt(ks, output, output);
    gift128n_to_nibbles(output, output);
}
