/*
 * Copyright (C) 2020 Southern Storm Software, Pty Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
\file algorithms.dox
\page algorithms Algorithms
\tableofcontents

This page lists all of the submissions to the second round of the
<a href="https://csrc.nist.gov/projects/lightweight-cryptography/round-2-candidates">NIST Lightweight Cryptography Competition</a>
and the degree of support for each algorithm in the library.

\section alg_which_one Which algorithm should I use?

This is a tough question given that as of early-2020 the NIST competition has
not yet whittled the list down or decided on final candidates.  But if you want
to get encrypting now:

\li \ref alg_ascon "ASCON-128" was already selected as a finalist for the
<a href="https://competitions.cr.yp.to/caesar-submissions.html">CAESAR
AEAD competition</a> (128-bit key).
\li \ref alg_gimli "Gimli" is the spiritual successor to the widely used
ChaCha20 and has a similar design (256-bit key).
\li \ref alg_comet "COMET-128_CHAM-128/128" is currently the fastest
algorithm in the library in terms of raw performance (128-bit key).
\li (others may be added here as I implement more algorithms)

Note that these are my own personal preferences and are not based on any
in-depth security analysis.  The above algorithms could fall to an attack
tomorrow but for now they have good space and speed trade-offs when
implemented in software on 32-bit platforms.

\section alg_no_aes Notes on algorithms that use AES

Some of the submissions to NIST use AES as the inner block cipher in the
AEAD implementation.  I haven't implemented any of those algorithms.
AES is notoriously difficult to implement in software in a manner that
avoids cache timing attacks.  It is best to ignore AES and do something else.

From a high level point of view, if AES is already suitable as a
lightweight cipher, then there's really no point to the NIST competition.
The most the competition can produce is a new block cipher mode, and that
mode could just as easily be used with a different block cipher that is
not subject to cache timing attacks.

\section alg_nonces Notes on AEAD algorithms and nonces

Every submission to the NIST competition takes the form of an
Authenticated Encryption with Associated Data (AEAD) scheme.
Such schemes typically take as input a key and a packet-specific nonce
to encrypt a given plaintext and to authenticate the ciphertext plus some
associated data (AD) that is not encrypted.

In the documentation for most AEAD schemes you will prominently find a
prescription that "The nonce must be unique for every packet.  If it isn't,
then the scheme is not secure".  Beginners to encryption can sometimes overlook
this and not take sufficient care to make the nonce unique (usually a
constantly-incrementing packet sequence number is sufficient).

To demonstrate why nonce reuse is bad, I'll briefly describe how AES-GCM
works as it is typical of AEAD schemes:

\li Generate a key stream KS from the Key and Nonce using AES in counter
mode where the nonce is used as the high-order bits of the counter.
In other words, KS = AES-CTR-STREAM(Key, Nonce).
\li XOR KS with the plaintext to produce the ciphertext.
\li Run the GCM authenticator over the associated data and ciphertext to
produce the authentication tag.

Now let's see what happens when we reuse the nonce.  We will have two
packets with the same keystream:

\li Ciphertext1 = Plaintext1 XOR KS
\li Ciphertext2 = Plaintext2 XOR KS

If an attacker was able to guess Plaintext1 because it is a standard
protocol header or similar, then they can trivially determine the
keystream and the other plaintext with:

\li KS = Ciphertext1 XOR Guessed-Plaintext1
\li Plaintext2 = Ciphertext2 XOR KS

This is why it is so important that the nonce be unique for every packet.
It is trivial to break many AEAD schemes if the nonce is chosen poorly.

Not all AEAD schemes are as vulnerable to nonce reuse.  SUNDAE-GIFT has a
variant with a zero-length nonce!  The SUNDAE-GIFT specification states
that as long as the combination (AD, Plaintext) is unique for each packet,
then there is no need for a nonce: the associated data AD acts like
a nonce.  But obviously you still need to be careful to make the
combination (AD, Plaintext) unique!

Below we will state any special considerations if the algorithm is
resistant against nonce reuse.  In the absence of any special considerations,
you should assume that changing the nonce for each packet is vital for
security.

\section alg_bugs Bugs

A few bugs were found in the reference code for some of the algorithms.
The bugs and their fixes are documented on \ref bugs "this page".

\section alg_ace ACE

TODO

\section alg_ascon ASCON

<b>Definition:</b> \ref ascon128.h

The ASCON family consists of the following AEAD algorithms:

\li ASCON-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag.
\li ASCON-128-a with a 128-bit key, a 128-bit nonce, and a 128-bit tag.
\li ASCON-80pq with a 160-bit key, a 128-bit nonce, and a 128-bit tag.

ASCON-128 is the recommended algorithm from the NIST submission.
ASCON-128-a is faster but does not mix the input state quite as
much as ASCON-128.  ASCON-80pq is essentially the same as ASCON-128
but it has a 160-bit key which may give added resistance against
quantum computers.

The library also implements the ASCON-HASH and ASCON-XOF hashing
algorithms as companions to the AEAD mode.

<b>Recommendation:</b> Use ASCON-128 for now unless you consider the
128-bit key length to be too short, in which case you should use ASCON-80pq.

\section alg_comet COMET

<b>Definition:</b> \ref comet.h

COMET is a family of authenticated encryption algorithms that are
built around an underlying block cipher.  This library implements
three members of the family:

\li COMET-128_CHAM-128/128 which has a 128-bit key, a 128-bit nonce,
and a 128-bit tag, built around the CHAM-128/128 block cipher.
\li COMET-64_CHAM-64/128 which has a 128-bit key, a 120-bit nonce,
and a 64-bit tag, built around the CHAM-64/128 block cipher.
\li COMET-64_SPECK-64/128 which has a 128-bit key, a 120-bit nonce,
and a 64-bit tag, built around the SPECK-64/128 block cipher.

There is also another family member COMET-128_AES-128/128 that is built
around AES but this library does not implement that version.

COMET-128_CHAM-128/128 is one of the fastest of the NIST algorithms in
software on 32-bit platforms.

<b>Recommendation:</b> The specification recommends COMET-128_AES-128/128 but
we don't implement AES-based schemes in this library.  Recommend to use
COMET-128_CHAM-128/128 instead.

\section alg_drygascon DryGASCON

TODO

\section alg_elephant Elephant

TODO

\section alg_estate ESTATE

<b>Definition:</b> \ref estate.h

<b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination
of the associated data (AD) and plaintext is unique.

ESTATE_TweGIFT-128 is an authenticated encryption algorithm with a
128-bit key, a 128-bit nonce, and a 128-bit tag.  It is a two-pass
algorithm that is built around a tweaked version of the GIFT-128 block
cipher, the FCBC authentication mode, and the OFB encryption mode.

ESTATE is resistant against nonce reuse as long as the combination
of the associated data and plaintext is unique.

If a nonce is reused then two packets with the same nonce, associated data,
and plaintext will encrypt to the same ciphertext.  This will leak that
the same plaintext has been sent for a second time but will not reveal
the plaintext itself.

The ESTATE family also includes variants build around tweaked versions
of the AES block cipher.  We do not implement those variants in this
library.

<b>Similar Algorithms:</b> \ref alg_gift_cofb "GIFT-COFB",
\ref alg_hyena "SUNDAE-GIFT", \ref alg_estate "HYENA"

\section alg_forkae ForkAE

TODO

\section alg_gift_cofb GIFT-COFB

<b>Definition:</b> \ref gift-cofb.h

GIFT-COFB is an authenticated encryption algorithm that combines
the COFB (COmbined FeedBack) block cipher mode with the bit-sliced
version of the GIFT-128 block cipher.  The algorithm has a 128-bit key,
a 128-bit nonce, and a 128-bit authentication tag.

The GIFT-128 block cipher was designed with hardware FPGA/ASIC implementations
in mind, so its software performance is not as great as other algorithms.
The implementation in the library is fairly well optimised for 32-bit
platforms so it is reasonably competitive with other schemes despite the
hardware design focus.

GIFT-COFB is a single-pass encryption algorithm, compared to the two-pass
algorithm used by SUNDAE-GIFT.  Out of all the GIFT-128 based submissions
to NIST, GIFT-COFB has the best software performance, although HYENA is
fairly close.

<b>Similar Algorithms:</b> \ref alg_sundae_gift "SUNDAE-GIFT",
\ref alg_hyena "HYENA", \ref alg_estate "ESTATE"

\section alg_gimli Gimli

<b>Definition:</b> \ref gimli24.h

GIMLI-24-CIPHER has a 256-bit key, a 128-bit nonce, and a 128-bit tag.
It is the spiritual successor to the widely used ChaCha20 and has a
similar design.

The library also includes an implementation of the hash algorithm
GIMLI-24-HASH in both regular hashing and XOF modes.

\section alg_grain_128aead Grain-128AEAD

TODO

\section alg_hyena HYENA

<b>Definition:</b> \ref hyena.h

HYENA is an authenticated encryption algorithm that implements a hybrid
feedback mode where a mixture of plaintext and ciphertext are mixed into
the state each block operation.

HYENA has a 128-bit key, a 96-bit nonce, and a 128-bit authentication tag.
It makes a single pass over the associated data and plaintext.

The block cipher in HYENA is the nibble-based version of GIFT-128.  This
makes HYENA slightly slower than GIFT-COFB in this implementation because
nibble-based GIFT-128 is implemented as a wrapper around the bit-sliced
version.  Using the bit-sliced version of GIFT-128 with HYENA would make it
slightly faster than GIFT-COFB.

<b>Similar Algorithms:</b> \ref alg_gift_cofb "GIFT-COFB",
\ref alg_hyena "SUNDAE-GIFT", \ref alg_estate "ESTATE"

\section alg_isap ISAP

TODO

\section alg_knot KNOT

TODO

\section alg_lotus LOTUS-AEAD and LOCUS-AEAD

TODO

\section alg_mixfeed mixFeed

Based on AES.  Not implemented.

\section alg_orange ORANGE

TODO

\section alg_oribatida Oribatida

TODO

\section alg_photon_beetle PHOTON-Beetle

TODO

\section alg_pyjamask Pyjamask

TODO

\section alg_romulus Romulus

TODO

\section alg_saeaes SAEAES

Based on AES.  Not implemented.

\section alg_saturnin Saturnin

<b>Definition:</b> \ref saturnin.h

Saturnin is a block cipher mode with a 256-bit key, a 128-bit nonce,
and a 256-bit authentication tag.  It is built around a bit-sliced variant
of AES that has a 256-bit block compared with AES's traditional 128-bit block.
The authors claim that the increased block size and the 256-bit key size
should give added protection against quantum computers.

Saturnin comes in two variants: SATURNIN-CTR-Cascade and SATURNIN-Short.
SATURNIN-CTR-Cascade works on arbitrary-sized inputs using a two-pass
combination of CTR mode with the Cascade authentication mode.

SATURNIN-Short is designed to work on short inputs of no more than 15 bytes
with no assoicated data and involves only a single block operation.  It is
very fast compared to other NIST submissions on short data.

The library also includes an implementation of the companion hash
algorithm SATURNIN-Hash.

<b>Recommendation:</b> SATURNIN-CTR-Cascade is the recommended variant
from the NIST submission.

\section alg_skinny SKINNY-AEAD

TODO

\section alg_sparkle SPARKLE

TODO

\section alg_spix SPIX

TODO

\section alg_spoc SpoC

TODO

\section alg_spook Spook

TODO

\section alg_subterranean Subterranean 2.0

TODO

\section alg_sundae_gift SUNDAE-GIFT

<b>Definition:</b> \ref sundae-gift.h

<b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination
of the associated data (AD) and plaintext is unique.

The SUNDAE-GIFT family consists of several related algorithms:

\li SUNDAE-GIFT-0 with a 128-bit key, a 0-bit nonce, and 128-bit tag.
\li SUNDAE-GIFT-64 with a 128-bit key, a 64-bit nonce, and 128-bit tag.
\li SUNDAE-GIFT-96 with a 128-bit key, a 96-bit nonce, and 128-bit tag.
This is the primary member of the family.
\li SUNDAE-GIFT-128 with a 128-bit key, a 128-bit nonce, and 128-bit tag.

SUNDAE-GIFT is built around the GIFT-128 block cipher in bit-sliced mode.
Two passes are made over the input data.  The first pass computes the
authentication tag over the nonce, associated data, and plaintext.
The second pass encrypts the plaintext to produce the ciphertext.

SUNDAE-GIFT is resistant against nonce reuse as long as the combination
of the associated data and plaintext is unique.

If a nonce is reused (or there is no nonce in the case of SUNDAE-GIFT-0),
then two packets with the same associated data and plaintext will encrypt
to the same ciphertext.  This will leak that the same plaintext has been
sent for a second time but will not reveal the plaintext itself.

<b>Recommendation:</b> SUNDAE-GIFT-96 is the recommended variant in the
NIST submission, with SUNDAE-GIFT-0 as the next-recommended variant.

<b>Similar Algorithms:</b> \ref alg_gift_cofb "GIFT-COFB",
\ref alg_hyena "HYENA", \ref alg_estate "ESTATE"

\section alg_tinyjambu TinyJambu

TODO

\section alg_wage WAGE

TODO

\section alg_xoodyak Xoodyak

TODO

\section alg_internal Internal block operations

Many of the algorithms are built on top of internal block ciphers and
sponge block operations.  Some of these operations are shared between
multiple algorithms so they are provided in a common internal location.

\li \ref internal-ascon.h "ASCON permutation"
\li \ref internal-cham.h "CHAM-128/128 and CHAM-64/128" block ciphers.
\li \ref internal-gift128.h "GIFT-128" block cipher in GIFT-128-b, GIFT-128-n, and TweGIFT-128 versions.
\li \ref internal-skinny128.h "SKINNY-128" block cipher in 128-bit, 256-bit, and 384-bit key size versions.

All of the internal block operations are implemented in source files that
start with the <tt>internal-</tt> prefix.  They are not intended to be part
of the public API for the AEAD algorithms.

*/
