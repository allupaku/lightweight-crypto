<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Lightweight Cryptography Primitives: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lightweight Cryptography Primitives
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#alg_which_one">Which algorithm should I use?</a></li>
<li class="level1"><a href="#alg_no_aes">Notes on algorithms that use AES</a></li>
<li class="level1"><a href="#alg_nonces">Notes on AEAD algorithms and nonces</a></li>
<li class="level1"><a href="#alg_bugs">Bugs</a></li>
<li class="level1"><a href="#alg_ace">ACE</a></li>
<li class="level1"><a href="#alg_ascon">ASCON</a></li>
<li class="level1"><a href="#alg_comet">COMET</a></li>
<li class="level1"><a href="#alg_drygascon">DryGASCON</a></li>
<li class="level1"><a href="#alg_elephant">Elephant</a></li>
<li class="level1"><a href="#alg_estate">ESTATE</a></li>
<li class="level1"><a href="#alg_forkae">ForkAE</a></li>
<li class="level1"><a href="#alg_gift_cofb">GIFT-COFB</a></li>
<li class="level1"><a href="#alg_gimli">Gimli</a></li>
<li class="level1"><a href="#alg_grain_128aead">Grain-128AEAD</a></li>
<li class="level1"><a href="#alg_hyena">HYENA</a></li>
<li class="level1"><a href="#alg_isap">ISAP</a></li>
<li class="level1"><a href="#alg_knot">KNOT</a></li>
<li class="level1"><a href="#alg_lotus">LOTUS-AEAD and LOCUS-AEAD</a></li>
<li class="level1"><a href="#alg_mixfeed">mixFeed</a></li>
<li class="level1"><a href="#alg_orange">ORANGE</a></li>
<li class="level1"><a href="#alg_oribatida">Oribatida</a></li>
<li class="level1"><a href="#alg_photon_beetle">PHOTON-Beetle</a></li>
<li class="level1"><a href="#alg_pyjamask">Pyjamask</a></li>
<li class="level1"><a href="#alg_romulus">Romulus</a></li>
<li class="level1"><a href="#alg_saeaes">SAEAES</a></li>
<li class="level1"><a href="#alg_saturnin">Saturnin</a></li>
<li class="level1"><a href="#alg_skinny">SKINNY-AEAD</a></li>
<li class="level1"><a href="#alg_sparkle">SPARKLE</a></li>
<li class="level1"><a href="#alg_spix">SPIX</a></li>
<li class="level1"><a href="#alg_spoc">SpoC</a></li>
<li class="level1"><a href="#alg_spook">Spook</a></li>
<li class="level1"><a href="#alg_subterranean">Subterranean 2.0</a></li>
<li class="level1"><a href="#alg_sundae_gift">SUNDAE-GIFT</a></li>
<li class="level1"><a href="#alg_tinyjambu">TinyJambu</a></li>
<li class="level1"><a href="#alg_wage">WAGE</a></li>
<li class="level1"><a href="#alg_xoodyak">Xoodyak</a></li>
<li class="level1"><a href="#alg_internal">Internal block operations</a></li>
</ul>
</div>
<div class="textblock"><p>This page lists all of the submissions to the second round of the <a href="https://csrc.nist.gov/projects/lightweight-cryptography/round-2-candidates">NIST Lightweight Cryptography Competition</a> and the degree of support for each algorithm in the library.</p>
<h1><a class="anchor" id="alg_which_one"></a>
Which algorithm should I use?</h1>
<p>This is a tough question given that as of early-2020 the NIST competition has not yet whittled the list down or decided on final candidates. But if you want to get encrypting now:</p>
<ul>
<li><a class="el" href="algorithms.html#alg_ascon">ASCON-128</a> was already selected as a finalist for the <a href="https://competitions.cr.yp.to/caesar-submissions.html">CAESAR AEAD competition</a> (128-bit key). </li>
<li><a class="el" href="algorithms.html#alg_gimli">Gimli</a> is the spiritual successor to the widely used ChaCha20 and has a similar design (256-bit key). </li>
<li><a class="el" href="algorithms.html#alg_comet">COMET-128_CHAM-128/128</a> is currently the fastest algorithm in the library in terms of raw performance (128-bit key). </li>
<li>(others may be added here as I implement more algorithms)</li>
</ul>
<p>Note that these are my own personal preferences and are not based on any in-depth security analysis. The above algorithms could fall to an attack tomorrow but for now they have good space and speed trade-offs when implemented in software on 32-bit platforms.</p>
<h1><a class="anchor" id="alg_no_aes"></a>
Notes on algorithms that use AES</h1>
<p>Some of the submissions to NIST use AES as the inner block cipher in the AEAD implementation. I haven't implemented any of those algorithms. AES is notoriously difficult to implement in software in a manner that avoids cache timing attacks. It is best to ignore AES and do something else.</p>
<p>From a high level point of view, if AES is already suitable as a lightweight cipher, then there's really no point to the NIST competition. The most the competition can produce is a new block cipher mode, and that mode could just as easily be used with a different block cipher that is not subject to cache timing attacks.</p>
<h1><a class="anchor" id="alg_nonces"></a>
Notes on AEAD algorithms and nonces</h1>
<p>Every submission to the NIST competition takes the form of an Authenticated Encryption with Associated Data (AEAD) scheme. Such schemes typically take as input a key and a packet-specific nonce to encrypt a given plaintext and to authenticate the ciphertext plus some associated data (AD) that is not encrypted.</p>
<p>In the documentation for most AEAD schemes you will prominently find a prescription that "The nonce must be unique for every packet.  If it isn't,
then the scheme is not secure". Beginners to encryption can sometimes overlook this and not take sufficient care to make the nonce unique (usually a constantly-incrementing packet sequence number is sufficient).</p>
<p>To demonstrate why nonce reuse is bad, I'll briefly describe how AES-GCM works as it is typical of AEAD schemes:</p>
<ul>
<li>Generate a key stream KS from the Key and Nonce using AES in counter mode where the nonce is used as the high-order bits of the counter. In other words, KS = AES-CTR-STREAM(Key, Nonce). </li>
<li>XOR KS with the plaintext to produce the ciphertext. </li>
<li>Run the GCM authenticator over the associated data and ciphertext to produce the authentication tag.</li>
</ul>
<p>Now let's see what happens when we reuse the nonce. We will have two packets with the same keystream:</p>
<ul>
<li>Ciphertext1 = Plaintext1 XOR KS </li>
<li>Ciphertext2 = Plaintext2 XOR KS</li>
</ul>
<p>If an attacker was able to guess Plaintext1 because it is a standard protocol header or similar, then they can trivially determine the keystream and the other plaintext with:</p>
<ul>
<li>KS = Ciphertext1 XOR Guessed-Plaintext1 </li>
<li>Plaintext2 = Ciphertext2 XOR KS</li>
</ul>
<p>This is why it is so important that the nonce be unique for every packet. It is trivial to break many AEAD schemes if the nonce is chosen poorly.</p>
<p>Not all AEAD schemes are as vulnerable to nonce reuse. SUNDAE-GIFT has a variant with a zero-length nonce! The SUNDAE-GIFT specification states that as long as the combination (AD, Plaintext) is unique for each packet, then there is no need for a nonce: the associated data AD acts like a nonce. But obviously you still need to be careful to make the combination (AD, Plaintext) unique!</p>
<p>Below we will state any special considerations if the algorithm is resistant against nonce reuse. In the absence of any special considerations, you should assume that changing the nonce for each packet is vital for security.</p>
<h1><a class="anchor" id="alg_bugs"></a>
Bugs</h1>
<p>A few bugs were found in the reference code for some of the algorithms. The bugs and their fixes are documented on <a class="el" href="bugs.html">this page</a>.</p>
<h1><a class="anchor" id="alg_ace"></a>
ACE</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_ascon"></a>
ASCON</h1>
<p><b>Definition:</b> <a class="el" href="ascon128_8h.html">ascon128.h</a></p>
<p>The ASCON family consists of the following AEAD algorithms:</p>
<ul>
<li>ASCON-128 with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ASCON-128-a with a 128-bit key, a 128-bit nonce, and a 128-bit tag. </li>
<li>ASCON-80pq with a 160-bit key, a 128-bit nonce, and a 128-bit tag.</li>
</ul>
<p>ASCON-128 is the recommended algorithm from the NIST submission. ASCON-128-a is faster but does not mix the input state quite as much as ASCON-128. ASCON-80pq is essentially the same as ASCON-128 but it has a 160-bit key which may give added resistance against quantum computers.</p>
<p>The library also implements the ASCON-HASH and ASCON-XOF hashing algorithms as companions to the AEAD mode.</p>
<p><b>Recommendation:</b> Use ASCON-128 for now unless you consider the 128-bit key length to be too short, in which case you should use ASCON-80pq.</p>
<h1><a class="anchor" id="alg_comet"></a>
COMET</h1>
<p><b>Definition:</b> <a class="el" href="comet_8h.html">comet.h</a></p>
<p>COMET is a family of authenticated encryption algorithms that are built around an underlying block cipher. This library implements three members of the family:</p>
<ul>
<li>COMET-128_CHAM-128/128 which has a 128-bit key, a 128-bit nonce, and a 128-bit tag, built around the CHAM-128/128 block cipher. </li>
<li>COMET-64_CHAM-64/128 which has a 128-bit key, a 120-bit nonce, and a 64-bit tag, built around the CHAM-64/128 block cipher. </li>
<li>COMET-64_SPECK-64/128 which has a 128-bit key, a 120-bit nonce, and a 64-bit tag, built around the SPECK-64/128 block cipher.</li>
</ul>
<p>There is also another family member COMET-128_AES-128/128 that is built around AES but this library does not implement that version.</p>
<p>COMET-128_CHAM-128/128 is one of the fastest of the NIST algorithms in software on 32-bit platforms.</p>
<p><b>Recommendation:</b> The specification recommends COMET-128_AES-128/128 but we don't implement AES-based schemes in this library. Recommend to use COMET-128_CHAM-128/128 instead.</p>
<h1><a class="anchor" id="alg_drygascon"></a>
DryGASCON</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_elephant"></a>
Elephant</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_estate"></a>
ESTATE</h1>
<p><b>Definition:</b> <a class="el" href="estate_8h.html">estate.h</a></p>
<p><b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination of the associated data (AD) and plaintext is unique.</p>
<p>ESTATE_TweGIFT-128 is an authenticated encryption algorithm with a 128-bit key, a 128-bit nonce, and a 128-bit tag. It is a two-pass algorithm that is built around a tweaked version of the GIFT-128 block cipher, the FCBC authentication mode, and the OFB encryption mode.</p>
<p>ESTATE is resistant against nonce reuse as long as the combination of the associated data and plaintext is unique.</p>
<p>If a nonce is reused then two packets with the same nonce, associated data, and plaintext will encrypt to the same ciphertext. This will leak that the same plaintext has been sent for a second time but will not reveal the plaintext itself.</p>
<p>The ESTATE family also includes variants build around tweaked versions of the AES block cipher. We do not implement those variants in this library.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a>, <a class="el" href="algorithms.html#alg_hyena">SUNDAE-GIFT</a>, <a class="el" href="algorithms.html#alg_estate">HYENA</a></p>
<h1><a class="anchor" id="alg_forkae"></a>
ForkAE</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_gift_cofb"></a>
GIFT-COFB</h1>
<p><b>Definition:</b> <a class="el" href="gift-cofb_8h.html">gift-cofb.h</a></p>
<p>GIFT-COFB is an authenticated encryption algorithm that combines the COFB (COmbined FeedBack) block cipher mode with the bit-sliced version of the GIFT-128 block cipher. The algorithm has a 128-bit key, a 128-bit nonce, and a 128-bit authentication tag.</p>
<p>The GIFT-128 block cipher was designed with hardware FPGA/ASIC implementations in mind, so its software performance is not as great as other algorithms. The implementation in the library is fairly well optimised for 32-bit platforms so it is reasonably competitive with other schemes despite the hardware design focus.</p>
<p>GIFT-COFB is a single-pass encryption algorithm, compared to the two-pass algorithm used by SUNDAE-GIFT. Out of all the GIFT-128 based submissions to NIST, GIFT-COFB has the best software performance, although HYENA is fairly close.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_sundae_gift">SUNDAE-GIFT</a>, <a class="el" href="algorithms.html#alg_hyena">HYENA</a>, <a class="el" href="algorithms.html#alg_estate">ESTATE</a></p>
<h1><a class="anchor" id="alg_gimli"></a>
Gimli</h1>
<p><b>Definition:</b> <a class="el" href="gimli24_8h.html">gimli24.h</a></p>
<p>GIMLI-24-CIPHER has a 256-bit key, a 128-bit nonce, and a 128-bit tag. It is the spiritual successor to the widely used ChaCha20 and has a similar design.</p>
<p>The library also includes an implementation of the hash algorithm GIMLI-24-HASH in both regular hashing and XOF modes.</p>
<h1><a class="anchor" id="alg_grain_128aead"></a>
Grain-128AEAD</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_hyena"></a>
HYENA</h1>
<p><b>Definition:</b> <a class="el" href="hyena_8h.html">hyena.h</a></p>
<p>HYENA is an authenticated encryption algorithm that implements a hybrid feedback mode where a mixture of plaintext and ciphertext are mixed into the state each block operation.</p>
<p>HYENA has a 128-bit key, a 96-bit nonce, and a 128-bit authentication tag. It makes a single pass over the associated data and plaintext.</p>
<p>The block cipher in HYENA is the nibble-based version of GIFT-128. This makes HYENA slightly slower than GIFT-COFB in this implementation because nibble-based GIFT-128 is implemented as a wrapper around the bit-sliced version. Using the bit-sliced version of GIFT-128 with HYENA would make it slightly faster than GIFT-COFB.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a>, <a class="el" href="algorithms.html#alg_hyena">SUNDAE-GIFT</a>, <a class="el" href="algorithms.html#alg_estate">ESTATE</a></p>
<h1><a class="anchor" id="alg_isap"></a>
ISAP</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_knot"></a>
KNOT</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_lotus"></a>
LOTUS-AEAD and LOCUS-AEAD</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_mixfeed"></a>
mixFeed</h1>
<p>Based on AES. Not implemented.</p>
<h1><a class="anchor" id="alg_orange"></a>
ORANGE</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_oribatida"></a>
Oribatida</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_photon_beetle"></a>
PHOTON-Beetle</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_pyjamask"></a>
Pyjamask</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_romulus"></a>
Romulus</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_saeaes"></a>
SAEAES</h1>
<p>Based on AES. Not implemented.</p>
<h1><a class="anchor" id="alg_saturnin"></a>
Saturnin</h1>
<p><b>Definition:</b> <a class="el" href="saturnin_8h.html">saturnin.h</a></p>
<p>Saturnin is a block cipher mode with a 256-bit key, a 128-bit nonce, and a 256-bit authentication tag. It is built around a bit-sliced variant of AES that has a 256-bit block compared with AES's traditional 128-bit block. The authors claim that the increased block size and the 256-bit key size should give added protection against quantum computers.</p>
<p>Saturnin comes in two variants: SATURNIN-CTR-Cascade and SATURNIN-Short. SATURNIN-CTR-Cascade works on arbitrary-sized inputs using a two-pass combination of CTR mode with the Cascade authentication mode.</p>
<p>SATURNIN-Short is designed to work on short inputs of no more than 15 bytes with no assoicated data and involves only a single block operation. It is very fast compared to other NIST submissions on short data.</p>
<p>The library also includes an implementation of the companion hash algorithm SATURNIN-Hash.</p>
<p><b>Recommendation:</b> SATURNIN-CTR-Cascade is the recommended variant from the NIST submission.</p>
<h1><a class="anchor" id="alg_skinny"></a>
SKINNY-AEAD</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_sparkle"></a>
SPARKLE</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_spix"></a>
SPIX</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_spoc"></a>
SpoC</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_spook"></a>
Spook</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_subterranean"></a>
Subterranean 2.0</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_sundae_gift"></a>
SUNDAE-GIFT</h1>
<p><b>Definition:</b> <a class="el" href="sundae-gift_8h.html">sundae-gift.h</a></p>
<p><b>Nonce Reuse:</b> Resistant against nonce reuse as long as the combination of the associated data (AD) and plaintext is unique.</p>
<p>The SUNDAE-GIFT family consists of several related algorithms:</p>
<ul>
<li>SUNDAE-GIFT-0 with a 128-bit key, a 0-bit nonce, and 128-bit tag. </li>
<li>SUNDAE-GIFT-64 with a 128-bit key, a 64-bit nonce, and 128-bit tag. </li>
<li>SUNDAE-GIFT-96 with a 128-bit key, a 96-bit nonce, and 128-bit tag. This is the primary member of the family. </li>
<li>SUNDAE-GIFT-128 with a 128-bit key, a 128-bit nonce, and 128-bit tag.</li>
</ul>
<p>SUNDAE-GIFT is built around the GIFT-128 block cipher in bit-sliced mode. Two passes are made over the input data. The first pass computes the authentication tag over the nonce, associated data, and plaintext. The second pass encrypts the plaintext to produce the ciphertext.</p>
<p>SUNDAE-GIFT is resistant against nonce reuse as long as the combination of the associated data and plaintext is unique.</p>
<p>If a nonce is reused (or there is no nonce in the case of SUNDAE-GIFT-0), then two packets with the same associated data and plaintext will encrypt to the same ciphertext. This will leak that the same plaintext has been sent for a second time but will not reveal the plaintext itself.</p>
<p><b>Recommendation:</b> SUNDAE-GIFT-96 is the recommended variant in the NIST submission, with SUNDAE-GIFT-0 as the next-recommended variant.</p>
<p><b>Similar Algorithms:</b> <a class="el" href="algorithms.html#alg_gift_cofb">GIFT-COFB</a>, <a class="el" href="algorithms.html#alg_hyena">HYENA</a>, <a class="el" href="algorithms.html#alg_estate">ESTATE</a></p>
<h1><a class="anchor" id="alg_tinyjambu"></a>
TinyJambu</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_wage"></a>
WAGE</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_xoodyak"></a>
Xoodyak</h1>
<p>TODO</p>
<h1><a class="anchor" id="alg_internal"></a>
Internal block operations</h1>
<p>Many of the algorithms are built on top of internal block ciphers and sponge block operations. Some of these operations are shared between multiple algorithms so they are provided in a common internal location.</p>
<ul>
<li><a class="el" href="internal-ascon_8h.html">ASCON permutation</a> </li>
<li><a class="el" href="internal-cham_8h.html">CHAM-128/128 and CHAM-64/128</a> block ciphers. </li>
<li><a class="el" href="internal-gift128_8h.html">GIFT-128</a> block cipher in GIFT-128-b, GIFT-128-n, and TweGIFT-128 versions. </li>
<li><a class="el" href="internal-skinny128_8h.html">SKINNY-128</a> block cipher in 128-bit, 256-bit, and 384-bit key size versions.</li>
</ul>
<p>All of the internal block operations are implemented in source files that start with the <code>internal-</code> prefix. They are not intended to be part of the public API for the AEAD algorithms. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 1 2020 13:12:21 for Lightweight Cryptography Primitives by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
